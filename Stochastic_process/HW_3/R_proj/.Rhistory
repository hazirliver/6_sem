))
#library(ggplot2)
main_func <- function(Tt, Hh, N, Mm_text, covar_text, t1, t2)
{
Mm <<- eval(parse(text = paste('Mm <- function(t) { return(' , Mm_text , ')}', sep='')))
covar <<- eval(parse(text = paste('covar <- function(t1,t2) { return(' , covar_text , ')}', sep='')))
### Функция моделирования одной траектории
trajectories <- function(Tt, Hh)
{
Nn <- Tt/Hh + 1
vect <- runif(Nn)
vect_expected <- Mm(vect)
Sigma_mat <- outer(vect,vect,FUN = covar)
eps <- runif(Nn)
L <- t(chol(Sigma_mat))
eta <- as.numeric(L %*% eps)
ksi <- vect + eta
return(ksi)
}
### Реплецирование
traj_list <- replicate(N, trajectories(Tt, Hh), simplify = F)
### Построение сечений с рассчетами corr, UB, LB
selected_cut <- as.data.frame(matrix(c(sapply(traj_list, `[[`, t1), sapply(traj_list, `[[`, t2)),
ncol = 2, byrow = F))
scatter_plot <- ggplot(selected_cut, aes(x = V1, y = V2)) + geom_point()
cor_test <- cor.test(selected_cut$V1, selected_cut$V2)
output_tmp_f <- list(matr = selected_cut, scatter = scatter_plot,
corr = cor_test)
### Формирование аутпута
corr <- as.numeric(output_tmp_f$corr$estimate)
corr_LB <- output_tmp_f$corr$conf.int[1]
corr_UB <- output_tmp_f$corr$conf.int[2]
output_main <- c(corr, corr_LB, corr_UB)
return(output_main)
}
library(shiny)
library(ggplot2)
source("./func.R")
source("./shinyapp/ui.R")
source("./shinyapp/server.R")
shinyApp(ui = ui, server = server)
View(covar)
View(main_func)
View(Mm)
View(server)
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('main.R')
runApp('shinyapp')
library(data.table)
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('main.R')
runApp('main.R')
runApp('shinyapp')
# Define UI for dataset viewer application
ui <- (pageWithSidebar(
# Application title
headerPanel("Введите исходные данные"),
# Sidebar with controls to select a dataset and specify the number
# of observations to view
sidebarPanel(
numericInput("Tt", "Конец интервала (T):", 10),
numericInput("Hh", "Шаг (h):", 0.05),
numericInput("N", "Количество траекторий:", 160),
textInput("Mm", "Математическое ожидание:", "1 + exp(-t)"),
textInput("covar", "Автоковариационная функция:", "2*exp(-abs(t2 - t1)/2)"),
numericInput("t_1", "Первое сечение:", 1),
numericInput("t_2", "Второе сечение:", 2)
),
# Show a summary of the dataset and an HTML table with the requested
# number of observations
mainPanel(
#h3(textOutput("caption")),
verbatimTextOutput("a")
#dataTableOutput("b"),
#textOutput("plot11"))
)
))
server <- function(input, output, session)
{
Tt <<- reactive(input$Tt)
Hh <<- reactive(input$Hh)
N <<- reactive(input$N)
Mm <<- reactive(input$Mm)
covar <<- reactive(input$covar)
t1 <<- reactive(input$t_1)
t2 <<- reactive(input$t_2)
#npt_seed <<- reactive((as.numeric(input$seed)))
#a <- main_func(Tt = 10,Hh = 0.05,N = 160, Mm_text = Mm, covar_text = covar, t1 = 1,t2 = 2)
#out_data_table <- data.table(rbind(c("r", "r_l", "r_u"),))
# cutt <- reactive(main_func(Tt = input$Tt,
#                            Hh = input$Hh,
#                            N = input$N,
#                            Mm_text = input$Mm,
#                            covar_text = input$covar,
#                            t1 = input$t_1,
#                            t2 = input$t_2)[4])
#
#output$plot11 <- reactive(asd)
output$a <- reactive(main_func(Tt = input$Tt,
Hh = input$Hh,
N = input$N,
Mm_text = input$Mm,
covar_text = input$covar,
t1 = input$t_1,
t2 = input$t_2)[-4])
}
#library(ggplot2)
main_func <- function(Tt, Hh, N, Mm_text, covar_text, t1, t2)
{
Mm <<- eval(parse(text = paste('Mm <- function(t) { return(' , Mm_text , ')}', sep='')))
covar <<- eval(parse(text = paste('covar <- function(t1,t2) { return(' , covar_text , ')}', sep='')))
### Функция моделирования одной траектории
trajectories <- function(Tt, Hh)
{
Nn <- Tt/Hh + 1
vect_rep <- repeatable(rnorm)
vect <- vect_rep(Nn)
vect_expected <- Mm(vect)
Sigma_mat <- outer(vect,vect,FUN = covar)
eps_rep <- repeatable(rnorm)
eps <- eps_rep(Nn)
L <- t(chol(Sigma_mat))
eta <- as.numeric(L %*% eps)
ksi <- vect + eta
return(ksi)
}
### Реплецирование
traj_list <- replicate(N, trajectories(Tt, Hh), simplify = F)
### Построение сечений с рассчетами corr, UB, LB
selected_cut <<- as.data.frame(matrix(c(sapply(traj_list, `[[`, t1), sapply(traj_list, `[[`, t2)),
ncol = 2, byrow = F))
scatter_plot <- ggplot(selected_cut, aes(x = V1, y = V2)) + geom_point()
cor_test <- cor.test(selected_cut$V1, selected_cut$V2)
output_tmp_f <- list(matr = selected_cut, scatter = scatter_plot,
corr = cor_test)
### Формирование аутпута
corr <- as.numeric(output_tmp_f$corr$estimate)
corr_LB <- output_tmp_f$corr$conf.int[1]
corr_UB <- output_tmp_f$corr$conf.int[2]
output_main <- c(corr, corr_LB, corr_UB, selected_cut)
return(output_main)
}
asd <<- selected_cut
library(shiny)
library(ggplot2)
library(data.table)
source("./func.R")
source("./shinyapp/ui.R")
source("./shinyapp/server.R")
shinyApp(ui = ui, server = server)
runApp('main.R')
server <- function(input, output, session)
{
Tt <<- reactive(input$Tt)
Hh <<- reactive(input$Hh)
N <<- reactive(input$N)
Mm <<- reactive(input$Mm)
covar <<- reactive(input$covar)
t1 <<- reactive(input$t_1)
t2 <<- reactive(input$t_2)
#npt_seed <<- reactive((as.numeric(input$seed)))
#a <- main_func(Tt = 10,Hh = 0.05,N = 160, Mm_text = Mm, covar_text = covar, t1 = 1,t2 = 2)
#out_data_table <- data.table(rbind(c("r", "r_l", "r_u"),))
# cutt <- reactive(main_func(Tt = input$Tt,
#                            Hh = input$Hh,
#                            N = input$N,
#                            Mm_text = input$Mm,
#                            covar_text = input$covar,
#                            t1 = input$t_1,
#                            t2 = input$t_2)[4])
#
#output$plot11 <- reactive(asd)
output$a <- reactive(main_func(Tt = input$Tt,
Hh = input$Hh,
N = input$N,
Mm_text = input$Mm,
covar_text = input$covar,
t1 = input$t_1,
t2 = input$t_2))
}
# Define UI for dataset viewer application
ui <- (pageWithSidebar(
# Application title
headerPanel("Введите исходные данные"),
# Sidebar with controls to select a dataset and specify the number
# of observations to view
sidebarPanel(
numericInput("Tt", "Конец интервала (T):", 10),
numericInput("Hh", "Шаг (h):", 0.05),
numericInput("N", "Количество траекторий:", 160),
textInput("Mm", "Математическое ожидание:", "1 + exp(-t)"),
textInput("covar", "Автоковариационная функция:", "2*exp(-abs(t2 - t1)/2)"),
numericInput("t_1", "Первое сечение:", 1),
numericInput("t_2", "Второе сечение:", 2)
),
# Show a summary of the dataset and an HTML table with the requested
# number of observations
mainPanel(
#h3(textOutput("caption")),
verbatimTextOutput("a")
#dataTableOutput("b"),
#textOutput("plot11"))
)
))
#library(ggplot2)
main_func <- function(Tt, Hh, N, Mm_text, covar_text, t1, t2)
{
Mm <<- eval(parse(text = paste('Mm <- function(t) { return(' , Mm_text , ')}', sep='')))
covar <<- eval(parse(text = paste('covar <- function(t1,t2) { return(' , covar_text , ')}', sep='')))
### Функция моделирования одной траектории
trajectories <- function(Tt, Hh)
{
Nn <- Tt/Hh + 1
vect_rep <- repeatable(rnorm)
vect <- vect_rep(Nn)
vect_expected <- Mm(vect)
Sigma_mat <- outer(vect,vect,FUN = covar)
eps_rep <- repeatable(rnorm)
eps <- eps_rep(Nn)
L <- t(chol(Sigma_mat))
eta <- as.numeric(L %*% eps)
ksi <- vect + eta
return(ksi)
}
### Реплецирование
traj_list <- replicate(N, trajectories(Tt, Hh), simplify = F)
### Построение сечений с рассчетами corr, UB, LB
selected_cut <- as.data.frame(matrix(c(sapply(traj_list, `[[`, t1), sapply(traj_list, `[[`, t2)),
ncol = 2, byrow = F))
scatter_plot <- ggplot(selected_cut, aes(x = V1, y = V2)) + geom_point()
cor_test <- cor.test(selected_cut$V1, selected_cut$V2)
output_tmp_f <- list(matr = selected_cut, scatter = scatter_plot,
corr = cor_test)
### Формирование аутпута
corr <- as.numeric(output_tmp_f$corr$estimate)
corr_LB <- output_tmp_f$corr$conf.int[1]
corr_UB <- output_tmp_f$corr$conf.int[2]
output_main <- c(corr, corr_LB, corr_UB)
return(output_main)
}
runApp('main.R')
library(shiny)
library(ggplot2)
library(data.table)
source("./func.R")
source("./shinyapp/ui.R")
source("./shinyapp/server.R")
shinyApp(ui = ui, server = server)
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
runApp('shinyapp')
install.packages("rsconnect")
rsconnect::setAccountInfo(name='hazirliver',
token='2E064CFD3CB4A9E25774670094962F12',
secret='<SECRET>')
rsconnect::setAccountInfo(name='hazirliver',
token='2E064CFD3CB4A9E25774670094962F12',
secret='<SECRET>')
library(rsconnect)
rsconnect::setAccountInfo(name='hazirliver',token='2E064CFD3CB4A9E25774670094962F12',secret='<SECRET>')
Sys.setlocale(locale="en_US.UTF-8")
if(all((localeToCharset()[1] == c("UTF-8", "CP949", "EUC-KR")) == FALSE)){
packageStartupMessage("This R shell doesn't contain any Hangul encoding.\nFor fully use, any of 'UTF-8', 'CP949', 'EUC-KR' needs to be used for R shell encoding.")
}
if(all((localeToCharset()[1] == c("UTF-8", "CP949", "EUC-KR")) == FALSE)){
packageStartupMessage("This R shell doesn't contain any Hangul encoding.\nFor fully use, any of 'UTF-8', 'CP949', 'EUC-KR' needs to be used for R shell encoding.")
}
rsconnect::setAccountInfo(name='hazirliver',token='2E064CFD3CB4A9E25774670094962F12',secret='5XXgH3XjPW8Iq1r5SADIHd0hd1G/4HptlaZQX/fk')
rsconnect::deployApp('.')
rsconnect::deployApp('./')
# INTERVAL [0;T] == [0;10]
# STEP == 0.05
# NUMBER n = 160
# EXPECTED VALUE m(t) = 1 + exp(-t)
# COVAR FUNC = 2*exp(-abs(tau)/2)
addTaskCallback(function(...) {set.seed(1337);TRUE})
library(ggplot2)
Tt <- 10
Hh <- 0.05
N <- 160
Mm <- function(t) {1 + exp(-t)}
covar <- function(t_1,t_2) {2*exp(-abs(t_2 - t_1)/2)}
Nn <- Tt/Hh
kh <- seq(0,Tt,Hh)
vect_expected <- Mm(kh)
Sigma_mat <- outer(kh,kh, FUN = covar)
eps <- rnorm(Nn+1, mean = 0, sd = 1)
L <- t(chol(Sigma_mat))
eta <- as.numeric(L %*% eps)
ksi <- vect_expected + eta
trajectories <- function(Tt, Hh)
{
Nn <- Tt/Hh
kh <- seq(0,Tt,Hh)
vect_expected <- Mm(kh)
Sigma_mat <- outer(kh,kh, FUN = covar)
eps <- rnorm(Nn+1, mean = 0, sd = 1)
L <- t(chol(Sigma_mat))
eta <- as.numeric(L %*% eps)
ksi <- vect_expected + eta
return(ksi)
}
################################################################
############################t1 = 1, t2 = 2
t1 <- 1
### Реплецирование
traj_list <- replicate(N, trajectories(Tt, Hh), simplify = F)
################################################################
############################t1 = 1, t2 = 2
t1 <- 1
t2 <- 2
selected_cut <- as.data.frame(matrix(c(sapply(traj_list, `[[`, t1),
sapply(traj_list, `[[`, t2)),
ncol = 2, byrow = F))
colnames(selected_cut) <- c("t1","t2")
head(selected_cut)
cor_test <- cor.test(selected_cut$t1, selected_cut$t2,
method = "pearson")
output_tmp_f <- list(matr = selected_cut, scatter = scatter_plot,
corr = cor_test)
### Формирование аутпута
corr <- as.numeric(cor_test$estimate)
corr_LB <- cor_test$conf.int[1]
corr_UB <- cor_test$conf.int[2]
corr
################################################################
############################t1 = 20, t2 = 150
t1 <- 20
t2 <- 150
selected_cut <- as.data.frame(matrix(c(sapply(traj_list, `[[`, t1),
sapply(traj_list, `[[`, t2)),
ncol = 2, byrow = F))
colnames(selected_cut) <- c("t1","t2")
head(selected_cut)
cor_test <- cor.test(selected_cut$t1, selected_cut$t2,
method = "pearson")
################################################################
############################t1 = 130, t2 = 155
t1 <- 130
t2 <- 155
selected_cut <- as.data.frame(matrix(c(sapply(traj_list, `[[`, t1),
sapply(traj_list, `[[`, t2)),
ncol = 2, byrow = F))
colnames(selected_cut) <- c("t1","t2")
head(selected_cut)
cor_test <- cor.test(selected_cut$t1, selected_cut$t2)
##########################################
traj_list_tr <- as.data.frame(t(simplify2array(traj_list)))
#install.packages("corrplot")
library(corrplot)
save.image("~/6_sem/Stochastic_process/HW_3/R_proj/before_corrplot.RData")
save.image("C:/R/backup_for_projects/before_corrplot.RData")
M<-cor(traj_list_tr)
M<-round(cor(traj_list_tr),2)
memory.limit()
Sys.getenv("R_ARCH")
1.759219e+13
corrplot(M, method="color")
corrplot(M, method="color", tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "ward.D2"
tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "ward.D2",
tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "ward.D2",
addrect = 10, tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "ward.D2",
addrect = 10, tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "ward.D2",
addrect = 5, tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "complete",
addrect = 5, tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "ward.D2",
addrect = 20, tl.pos='n')
corrplot(M, method="color", tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "ward.D2",
addrect = 200, tl.pos='n')
corrplot(M, method="color", tl.pos='n')
##########################################
traj_list_tr <- as.data.frame(t(simplify2array(traj_list)))
#install.packages("corrplot")
library(corrplot)
M<-round(cor(traj_list_tr),2)
M[1:10,1:10]
dim(M)
#install.packages("corrplot")
library(corrplot)
corrplot(M, method="color", tl.pos='n')
png(filename = "../img/corrplot.png",
width = 1920, height = 1080,
res = 96 * 3)
corrplot(M, method="color", tl.pos='n')
dev.off()
abline(a = 1, b = 2)
abline(a = -1, b = 2)
abline(a = -1, b = -2)
abline(a = 5, b = -1)
abline(a = 50, b = -1)
abline(a = 250, b = -1)
abline(a = 300, b = -1)
abline(a = 260, b = -1)
lines(c(2.5, 2.5), c(0, 12), lwd=3, lty=2)
lines(c(0, 260), c(260, 0), lwd=3, lty=2)
corrplot(M, method="color", tl.pos='n')
lines(c(0, 150), c(150, 0), lwd=3, lty=2)
lines(c(50, 200), c(200, 50), lwd=3, lty=2)
corrplot(M, method="color", order = "hclust", hclust.method = "ward.D2",
addrect = 3, tl.pos='n')
png(filename = "../img/corrplot_clustered.png",
width = 1920, height = 1080,
res = 96 * 3)
corrplot(M, method="color", tl.pos='n')
lines(c(1, 150), c(150, 1), lwd=3, lty=2)
lines(c(50, 200), c(200, 50), lwd=3, lty=2)
dev.off()
png(filename = "../img/corrplot_clustered.png",
width = 1920, height = 1080,
res = 96 * 3)
corrplot(M, method="color", tl.pos='n')
lines(c(1, 150), c(150, 1), lwd=3, lty=2)
lines(c(50, 201), c(201, 50), lwd=3, lty=2)
dev.off()
corrplot(M, method="color", order = "AOE",tl.pos='n')
corrplot(M, method="color", order = "FPC",tl.pos='n')
corrplot(M, method="color", order = "hclust",tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "complete",tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "ward",tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "ward.D",tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "single",tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "average",tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "mcquitty",tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "median",tl.pos='n')
corrplot(M, method="color", order = "hclust", hclust.method = "centroid",tl.pos='n')
M[M<0]
count(M[M<0])
length(M[M<0])
length(M[M>0])
length(M)
M_negative
M_negative <- length(M[M<0])
M_negative
M_negative_perc <- M_negative / length(M)
M_negative_perc
M_negative_perc
length(M)
201*201
M_negative <- length(M[M<0])
M_negative # Число отрицательных коэффициентов корреляции
length(M) # Количество элементов в корреляционной матрице (201*201)
M_negative_perc <- M_negative / length(M)
M_negative_perc # Процент отрицательных элементов
